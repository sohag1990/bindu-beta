package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	helper "github.com/bindu-bindu/bindu/Helper"
	"github.com/gertd/go-pluralize"
	"github.com/spf13/cobra"
)

// Generator is a func to generate model controller and scaffold
func Generator(cmd *cobra.Command, c helper.CommandChain) {
	// User command args
	args := c.GetArgs()

	// flags := c.GetFlags()
	genItems := []string{"Model", "Controller", "Scaffold", "View"}
	// if no agruments Prompt to select action name eg. model, controller, scaffold, view
	if len(args) == 0 {
		_, actionName := helper.AskSelect("Select To Generate", genItems)
		args = append(args, actionName)
		c.SetCliArgs(args)
	}

	// check the first items is matched with predefined arg.. Controller, Model,,,etc
	i, found := helper.ArrayFind(genItems, args[0])
	if found {
		switch i {
		case 0:
			fmt.Printf("%v\n", "Model action")
			// Model Generator
			ModelGenerator(cmd, c)

			// case 1:
			// 	fmt.Printf("%v\n", "Controller action")
			// 	ControllerGenerator(args)
			// case 2:
			// 	// fmt.Printf("%v\n", "Scaffold action")
			// 	ModelGenerator(cmd, args)
			// 	ControllerGenerator(args)
			// 	RoutesGenerator(args)
			// case 3:
			// 	fmt.Printf("%v\n", "View action")
			// 	fmt.Printf("%v\n", args)
			// default:
			// 	fmt.Printf("%v\n", "No action taken")
			// 	fmt.Printf("%v\n", args)
		}

	}
}

// ModelGenerator to generate the model in project using the user inputs
func ModelGenerator(cmd *cobra.Command, c helper.CommandChain) {
	args := c.GetArgs()
	flags := c.GetFlags()
	plural := pluralize.NewClient()
	modelName := args[1]

	// return
	newpath := filepath.Join(".", "app/models")
	os.MkdirAll(newpath, os.ModePerm)
	fp := "./app/models/" + modelName + ".go"
	if helper.FileExists(fp) {
		fmt.Println("Model already exist. If you want to update model,\nuse the update instead generate command")
		return
	}
	f, err := os.Create(fp)
	helper.ErrorCheck(err)
	f.WriteString("package models\n\n")
	f.WriteString("// " + modelName + " public model generated by bindu\n")
	f.WriteString("type " + modelName + " struct {\n")
	// Initialize Primary, CreatedAt, UpdatedAt, DeletedAt property
	f.WriteString("\tDefaultProperties\n")
	for _, prop := range args[2:] {
		f.WriteString("\t" + helper.PropertyFormatter(prop) + "\n")
	}
	for _, flg := range flags {
		key := flg.Key
		values := flg.Values
		if key == "hasOne" && len(values) > 0 {
			splitData := strings.Split(values[0], "^")
			firstModelArr := strings.Split(splitData[0], ":")
			f.WriteString("\t" + strings.Title(firstModelArr[0]) + " " + strings.Title(firstModelArr[0]) + "\n")
			modelIfNotExistCreate(strings.Title(firstModelArr[0]), args)
		}
		if key == "belongsTo" && len(values) > 0 {
			splitData := strings.Split(values[0], "^")
			firstModelArr := strings.Split(splitData[0], ":")
			f.WriteString("\t" + firstModelArr[0] + " " + firstModelArr[0] + "\n")
			f.WriteString("\t" + firstModelArr[0] + "ID   uint64\n")
			modelIfNotExistCreate(firstModelArr[0], args)
		}
		if key == "hasMany" && len(values) > 0 {
			splitData := strings.Split(values[0], "^")
			firstModelArr := strings.Split(splitData[0], ":")
			f.WriteString("\t" + firstModelArr[0] + " []" + firstModelArr[0] + "\n")
			modelIfNotExistCreate(firstModelArr[0], args)
		}
		if key == "manyToMany" && len(values) > 0 {
			splitData := strings.Split(values[0], "^")
			firstModelArr := strings.Split(splitData[0], ":")
			f.WriteString("\t" + firstModelArr[0] + " []" + firstModelArr[0] + " `gorm:\"many2many:" + args[1] + "_" + plural.Plural(firstModelArr[0]) + ";\"`\n")
			modelIfNotExistCreateManyToMany(firstModelArr[0], args)
		}
	}

	f.WriteString("}")
	defer f.Close()
	absPath, _ := filepath.Abs(newpath)
	fmt.Println(absPath + "/" + args[1] + ".go")

}
func modelIfNotExistCreateManyToMany(model string, args []string) {
	plural := pluralize.NewClient()
	path := "./app/models/" + model + ".go"
	if helper.FileExists(path) {
		fmt.Println("Model already exist. If you want to update model,\nuse the update instead generate command")
		return
	}

	f, err := os.Create(path)
	helper.ErrorCheck(err)
	f.WriteString("package models\n\n")
	f.WriteString("// " + model + " public model generated by bindu\n")
	f.WriteString("type " + model + " struct {\n")
	// Initialize Primary, CreatedAt, UpdatedAt, DeletedAt property
	f.WriteString("\tDefaultProperties\n")
	f.WriteString("\t" + args[1] + " []" + args[1] + " `gorm:\"many2many:" + args[1] + "_" + plural.Plural(model) + ";\"`\n")
	f.WriteString("}")
	defer f.Close()

}

func modelIfNotExistCreate(model string, args []string) {
	path := "./app/models/" + model + ".go"
	if helper.FileExists(path) {
		fmt.Println("If you want to update model,\nuse the update instead generate command")
		return
	}
	f, err := os.Create(path)
	helper.ErrorCheck(err)
	f.WriteString("package models\n\n")
	f.WriteString("// " + model + " public model generated by bindu\n")
	f.WriteString("type " + model + " struct {\n")
	// Initialize Primary, CreatedAt, UpdatedAt, DeletedAt property
	f.WriteString("\tDefaultProperties\n")
	f.WriteString("\t" + args[1] + "ID uint64\n")
	f.WriteString("}")
	defer f.Close()

}

// // ControllerGenerator to generate the controller in project using the user inputs
// func ControllerGenerator(args []string) {
// 	// fmt.Println(args)

// 	fmt.Println("Initializing Controller " + args[1])
// 	newpath := filepath.Join(".", "app/controllers")
// 	os.MkdirAll(newpath, os.ModePerm)
// 	// Model name
// 	plural := pluralize.NewClient()
// 	modelVar := strings.ToLower(args[1])
// 	modelVar2 := strings.ToLower(args[1]) + "2"
// 	f, err := os.Create("./app/controllers/" + args[1] + "Controller.go")
// 	helper.ErrorCheck(err)
// 	f.WriteString("package controllers\n\n")
// 	f.WriteString("import (\n\n")
// 	f.WriteString("\t\"github.com/gin-gonic/gin\"\n")
// 	f.WriteString("\t\"" + helper.GetEnvValueByKey(".env", "APP_IMPORT_PATH") + "/app/models\"\n")
// 	f.WriteString("\t\"" + helper.GetEnvValueByKey(".env", "APP_IMPORT_PATH") + "/db\"\n")
// 	f.WriteString(")\n\n")

// 	f.WriteString("// " + args[1] + " public controllers generated by bindu\n")
// 	// Generate CRUD
// 	// Get All Data for Index
// 	f.WriteString("func Index" + args[1] + "(c *gin.Context) {\n")
// 	// Controller functionality here
// 	// model collection initialize
// 	f.WriteString("\tpage := c.Params.ByName(\"page\")\n")
// 	f.WriteString("\tlimit := 10\n")
// 	f.WriteString("\tvar db = db.DB\n")

// 	f.WriteString("\tvar " + plural.Plural(modelVar) + " []models." + args[1] + "\n")
// 	f.WriteString("\tdb.Find(&" + plural.Plural(modelVar) + ").Offset(page).Limit(limit)\n\n")

// 	f.WriteString("\tc.JSON(200, " + plural.Plural(modelVar) + ")\n")
// 	f.WriteString("}\n\n")

// 	// Get Single Data for Show
// 	f.WriteString("func Show" + args[1] + "(c *gin.Context) {\n")
// 	// Controller functionality here
// 	f.WriteString("\tid := c.Params.ByName(\"id\")\n")
// 	f.WriteString("\tvar db = db.DB\n")
// 	f.WriteString("\tvar " + modelVar + " models." + args[1] + "\n")
// 	f.WriteString("\tdb.Where(\"id=?\",id).Find(&" + modelVar + ")\n\n")

// 	f.WriteString("\tc.JSON(200, " + modelVar + ")\n")
// 	f.WriteString("}\n\n")

// 	// Post Single Data for New
// 	f.WriteString("func Create" + args[1] + "(c *gin.Context) {\n")
// 	// Controller functionality here
// 	f.WriteString("\tvar db = db.DB\n")
// 	f.WriteString("\tvar " + modelVar + " models." + args[1] + "\n")
// 	f.WriteString("\tc.BindJSON(&" + modelVar + ")\n")
// 	f.WriteString("\tdb.Create(&" + modelVar + ")\n\n")

// 	f.WriteString("\tc.JSON(200, " + modelVar + ")\n")
// 	f.WriteString("}\n\n")

// 	// Post Single Data for Create
// 	f.WriteString("func New" + args[1] + "(c *gin.Context) {\n")
// 	// Controller functionality here
// 	f.WriteString("\tc.JSON(200, \"" + args[1] + " Create page\")\n")
// 	f.WriteString("}\n\n")

// 	// Create New Data for Update
// 	f.WriteString("func Update" + args[1] + "(c *gin.Context) {\n")
// 	// Controller functionality here
// 	f.WriteString("\tid := c.Params.ByName(\"id\")\n")
// 	f.WriteString("\tvar db = db.DB\n")
// 	f.WriteString("\tvar " + modelVar + " models." + args[1] + "\n")
// 	f.WriteString("\tvar " + modelVar2 + " models." + args[1] + "\n")
// 	f.WriteString("\tc.BindJSON(&" + modelVar + ")\n")

// 	f.WriteString("\tif err := db.Where(\"id=?\",id).Find(&" + modelVar2 + ").Error; err != nil {\n")
// 	f.WriteString("\tc.JSON(404, " + modelVar2 + ")\n")
// 	f.WriteString("return\n}\n\n")

// 	f.WriteString("\tdb.Model(&" + modelVar2 + ").Update(&" + modelVar + ")\n\n")

// 	f.WriteString("\tc.JSON(200, " + modelVar + ")\n")
// 	f.WriteString("}\n\n")

// 	// Get Single Data for Destroy
// 	f.WriteString("func Destroy" + args[1] + "(c *gin.Context) {\n")
// 	// Controller functionality here
// 	f.WriteString("\tid := c.Params.ByName(\"id\")\n")
// 	f.WriteString("\tvar db = db.DB\n")
// 	f.WriteString("\tvar " + modelVar + " models." + args[1] + "\n")

// 	f.WriteString("\tif err := db.Where(\"id=?\",id).Find(&" + modelVar + ").Error; err != nil {\n")
// 	f.WriteString("\tc.JSON(404, " + modelVar + ")\n")
// 	f.WriteString("return\n}\n\n")

// 	f.WriteString("\tdb.Delete(&" + modelVar + ")\n\n")

// 	f.WriteString("\tc.JSON(200, " + modelVar + ")\n")
// 	f.WriteString("}\n\n")

// 	defer f.Close()
// 	absPath, _ := filepath.Abs(newpath)
// 	fmt.Println(absPath + "/" + args[1] + "Controller.go\n")

// }

// // RoutesGenerator Routes generator
// func RoutesGenerator(args []string) {
// 	// routes not working... it should do first, find the fucname and append lines before return
// 	helper.WriteRoutes("routes/API.go", args[1])
// }
