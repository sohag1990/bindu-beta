package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	helper "github.com/bindu-bindu/bindu/Helper"
	story "github.com/bindu-bindu/bindu/Story"
	"github.com/gertd/go-pluralize"
	"github.com/spf13/cobra"
)

// --update or -u flag variable
var u bool

// Generator is a func to generate model controller and scaffold
func Generator(cmd *cobra.Command, cli helper.CommandChain) bool {
	// To return a status true or false, whether code executed or not
	// Deafult true
	status := true
	//--update flag check.
	u, _ = strconv.ParseBool(fmt.Sprintf("%v", cmd.Flag("update").Value))
	// User command args
	args := cli.GetArgs()

	// flags := c.GetFlags()
	genItems := []string{"Model", "Controller", "Scaffold", "Routes", "View", "Auth"}
	// if no agruments Prompt to select action name eg. model, controller, scaffold, view
	if len(args) == 0 {
		fmt.Println("Arguments not enough to generate Model, Controller, Scaffold, Routes, View or Auth")
		story.UpdateThisStoryStatus("false: No enough agruments for generate command")
		return false
		//user simulation fix letter
		_, actionName := helper.AskSelect("Select To Generate", genItems)
		args = append(args, actionName)
		cli.SetCliArgs(args)
	}

	// check the first items is matched with predefined arg.. Controller, Model,,,etc
	i, found := helper.ArrayFind(genItems, args[0])
	if found {
		switch i {
		case 0:
			// fmt.Printf("%v\n", "Action to generate new model")
			// Model Generator
			status = ModelGenerator(cmd, cli)

		case 1:
			// fmt.Printf("%v\n", "Controller action")
			status = ControllerGenerator(cmd, cli)

		case 2:
			// fmt.Printf("%v\n", "Scaffold action")
			status = ModelGenerator(cmd, cli)
			status = ControllerGenerator(cmd, cli)

		case 3:
			// fmt.Printf("%v\n", "Routes action")
			status = RoutesGenerator(cmd, cli)

		case 4:
			// view not ready yet
		case 5:
			// For auth do not take any args from input
			// initialize the args as User and UserName:string then procced
			// args = cli.GetArgs()[:1]
			// args = append(args, "User")
			// cli.SetCliArgs(args)
			// fmt.Println(cli.GetArgs())
			// check if exist the User model If not create. if exist Not update flag true. to update the property
			//file path of the model
			// fp := "./app/models/User.go"
			// check if the file exist. if exist then suggest to change the command update instead generate
			// if helper.FileExists(fp) {
			// 	u = true
			// }

			// fmt.Printf("%v\n", "Scaffold action")
			// status = ModelGenerator(cmd, cli)
			// status = ControllerGenerator(args)
			// status = RoutesGenerator(args)
			// append Login path to main Routes
			// lineAfter := []string{
			// 	"Use(middlewares.Cors())",
			// 	"func API",
			// 	"func API(r *gin.Engine) *gin.Engine {",
			// }
			// fmt.Println("Generating Login Routes....")

			// var newLines []string
			// newLines = append(newLines, "\n\t// Login Routes generated by bindu\n")
			// newLines = append(newLines, "\tr.POST(\"/login\", middlewares.GinJwtMiddlewareHandler().LoginHandler)")
			// Generate Routes
			// helper.AppendLinesInFile("routes/API.go", lineAfter, newLines)
		}

	} else {

		fmt.Println("Error: Incorrect arguments, Do you meen? 'bindu generate model " + args[0] + "...'")
		fmt.Println("Available arguments: ", genItems)
		story.UpdateThisStoryStatus("False: incorrect command, Missing argument")
	}
	return status
}

// ModelGenerator to generate the model in project using the user inputs
func ModelGenerator(cmd *cobra.Command, cli helper.CommandChain) bool {
	status := true
	// get all others args and flags
	args := cli.GetArgs()
	flags := cli.GetFlags()

	plural := pluralize.NewClient()
	modelName := args[1]

	// if directory not present create models dir
	newpath := filepath.Join(".", "app/models")
	os.MkdirAll(newpath, os.ModePerm)
	//file path of the model
	fp := "./app/models/" + strings.Title(modelName) + ".go"
	// check if the file exist. if exist then suggest to change the command update instead generate
	if helper.FileExists(fp) {
		// check if genarator should update or modify files
		fmt.Println("Model '" + strings.Title(modelName) + "' already exist...")
		if !u {
			fmt.Println("If you want to update model,\nuse the --update(-u)  flag to modify")
			story.UpdateThisStoryStatus("false: '" + modelName + "' Model Already exist!")
			return false
		}
	}
	// Create model if not exist, ofcouse not present at this moment, create one
	// append model properties in the model
	lineAfter := []string{"type " + modelName + " struct {", "type " + modelName}
	var newLines []string
	for _, prop := range args[2:] {
		newLines = append(newLines, helper.PropertyFormatter(prop))
	}

	// if --update flag fired update the model
	if u {
		helper.AppendLinesInFile(fp, lineAfter, newLines)
	}
	// Create the main model
	modelName = strings.Title(modelName)
	status = modelIfNotExistCreate(modelName, newLines)

	for _, flg := range flags {
		keyFlag := flg.Key
		valueFlag := flg.Values
		// SubcommandChain find the subcommand args
		subcommandChain := helper.SubCommandChain(valueFlag)
		// Check if subcommand exist then procced
		if len(subcommandChain) > 0 {
			// flags arguments commandChain first item is relationship model
			relModel := subcommandChain[0]
			// check if more than one rel models
			splitRelModel := strings.Split(relModel, "-")

			for in, makeTitle := range splitRelModel {
				splitRelModel[in] = strings.Title(makeTitle)
			}
			if keyFlag == "hasOne" {

				for _, rModel := range splitRelModel {
					// append new lines to the main model
					helper.AppendLinesInFile(fp, lineAfter, []string{"\t" + rModel + " " + rModel})
					// create related hasOne model
					status = modelIfNotExistCreate(rModel, []string{"\t" + strings.Title(args[1]) + "ID uint64 `json:\"-\"`"})
				}
			}
			if keyFlag == "belongsTo" {

				for _, rModel := range splitRelModel {
					// belongs to properties for main model
					belongsToProps := []string{
						"\t" + rModel + " " + rModel,
						"\t" + rModel + "ID   uint64 `json:\"-\"`",
					}
					// append line to main model
					helper.AppendLinesInFile(fp, lineAfter, belongsToProps)
					// belongs to model
					status = modelIfNotExistCreate(rModel, nil)
				}
			}
			if keyFlag == "hasMany" {
				// hasMany properties for main model

				for _, rModel := range splitRelModel {
					hasManyProps := []string{
						"\t" + plural.Plural(rModel) + " []" + rModel,
					}
					// append line to main model
					helper.AppendLinesInFile(fp, lineAfter, hasManyProps)
					// belongs to model
					status = modelIfNotExistCreate(rModel, []string{"\t" + strings.Title(modelName) + "ID   uint64 `json:\"-\"`"})
				}

			}
			if keyFlag == "manyToMany" {

				for _, rModel := range splitRelModel {
					// manyToMany properties for main model
					manyToManyProps := []string{
						"\t" + plural.Plural(rModel) + " []" + rModel + " `gorm:\"many2many:" + strings.ToLower(args[1]) + "_" + plural.Plural(strings.ToLower(rModel)) + ";association_foreignkey:id;foreignkey:id\"`",
					}
					// append line to main model
					helper.AppendLinesInFile(fp, lineAfter, manyToManyProps)
					// Crate manyToMany model if not exist
					// manyToMany Relationship
					status = modelIfNotExistCreate(rModel, []string{"\t" + strings.Title(plural.Plural(args[1])) + " []" + args[1] + " `gorm:\"many2many:" + strings.ToLower(args[1]) + "_" + plural.Plural(strings.ToLower(rModel)) + ";association_foreignkey:id;foreignkey:id\"`\n"})
				}
			}
		}
	}
	// import package if requires
	for _, prop := range args[2:] {
		p := strings.Split(prop, ":")
		if len(p) >= 2 {
			pVal := strings.ToLower(p[1])
			pValLimit := strings.Split(pVal, "_")
			if pValLimit[0] == "time" || pValLimit[0] == "date" || pValLimit[0] == "date" || pValLimit[0] == "datetime" || pValLimit[0] == "time.Time" {
				//import time lib
				newLines1 := []string{
					fmt.Sprintf("%v", "import \"time\""),
				}
				lineAfter1 := []string{
					fmt.Sprintf("%v", "package models"),
				}
				path := "./app/models/" + strings.Title(modelName) + ".go"
				helper.AppendLinesInFileNext(path, lineAfter1, 1, newLines1)
			}
		}
	}
	return status
}

// modelIfNotExistCreate create model if not exist input model and props as string line
func modelIfNotExistCreate(model string, props []string) bool {

	path := "./app/models/" + model + ".go"
	if helper.FileExists(path) {
		fmt.Println("Failed to generate model!!! Model already exist.")
		story.UpdateThisStoryStatus("false: '" + path + "' Model Already exist!")
		return false
	}
	fmt.Println("Model creating..." + path)
	f, err := os.Create(path)
	helper.ErrorCheck(err)
	f.WriteString("package models\n\n")
	f.WriteString("// " + model + " public model generated by bindu\n")
	f.WriteString("type " + model + " struct {\n")

	for _, p := range props {
		f.WriteString(p + "\n")
	}

	// Initialize Primary, CreatedAt, UpdatedAt, DeletedAt property
	f.WriteString("\tDefaultProperties\n")
	f.WriteString("}")
	defer f.Close()
	fmt.Println(".......Success!")
	story.UpdateThisStoryStatus("true: '" + model + "' Created")
	return true
}

// ControllerGenerator to generate the controller in project using the user inputs
func ControllerGenerator(cmd *cobra.Command, cli helper.CommandChain) bool {
	args := cli.GetArgs()
	flags := cli.GetFlags()

	relModels := helper.FindAssociationRecursivly(args[1])
	preloads := helper.CreatePreloadByModels(relModels)
	for _, flg := range flags {
		keyFlag := flg.Key
		if keyFlag == "method" || keyFlag == "methods" {
			valueFlag := flg.Values
			// SubcommandChain find the subcommand args
			subcommandChain := helper.SubCommandChain(valueFlag)

			// Check if subcommand exist then procced
			if len(subcommandChain) > 0 {
				fmt.Println(subcommandChain)
				// flags arguments commandChain first item is relationship model
				methods := subcommandChain[0]

				// check if more than one rel models
				methodNames := strings.Split(methods, "-")
				i := 0
				for _, methodName := range methodNames {
					mN := strings.ToLower(methodName)
					if mN == "all" || mN == "get" || mN == "post" || mN == "put" || mN == "delete" {
						methodNames[i] = mN
						i++
					}
				}

				methodNames = methodNames[:i]
				if len(methodNames) > 0 {

					// creating controller and methods
					modelName := strings.Title(args[1])
					fp := "./app/models/" + strings.Title(modelName) + ".go"
					// check if the file exist. if exist then suggest to change the command update instead generate
					if !helper.FileExists(fp) {
						fmt.Println("Error: Model " + modelName + " not found")
						story.UpdateThisStoryStatus("Error: Model " + modelName + " not found!")
						return false
					}
					fmt.Println("Initializing Controller " + modelName)
					newpath := filepath.Join(".", "app/controllers")
					os.MkdirAll(newpath, os.ModePerm)
					// Model name

					plural := pluralize.NewClient()
					modelVar := strings.ToLower(modelName)
					modelVar2 := strings.ToLower(modelName) + "2"
					path := "./app/controllers/" + modelName + "Controller.go"
					if helper.FileExists(path) {
						fmt.Println("Failed to generate controller!!!\nIf you want to update Controller,\nuse the --update or -u flag to add new or modify")
						story.UpdateThisStoryStatus("false: Already Exist (-u To Update) '" + path + "' ")
						return false
					}
					// If controller not exist then generate
					f, err := os.Create(path)
					helper.ErrorCheck(err)
					f.WriteString("package controllers\n\n")
					f.WriteString("import (\n\n")
					f.WriteString("\t\"github.com/gin-gonic/gin\"\n")
					f.WriteString("\t\"" + helper.GetEnvValueByKey(".env", "APP_IMPORT_PATH") + "/app/models\"\n")
					f.WriteString("\t\"" + helper.GetEnvValueByKey(".env", "APP_IMPORT_PATH") + "/db\"\n")
					f.WriteString(")\n\n")

					f.WriteString("// " + modelName + " public controllers generated by bindu\n\n")
					// Generate CRUD
					_, allMethodfound := helper.ArrayFind(methodNames, "all")
					_, getMethodfound := helper.ArrayFind(methodNames, "get")
					if getMethodfound || allMethodfound {

						// Get All Data for Index
						f.WriteString("// Index" + modelName + " to get all data\n")
						f.WriteString("func Index" + modelName + "(c *gin.Context) {\n")
						// Controller functionality here
						// model collection initialize
						f.WriteString("\tpage := c.Params.ByName(\"page\")\n")
						f.WriteString("\tlimit := 10\n")
						f.WriteString("\tvar db = db.DB\n")

						f.WriteString("\tvar " + plural.Plural(modelVar) + " []models." + modelName + "\n")
						f.WriteString("\tdb" + preloads + ".Find(&" + plural.Plural(modelVar) + ").Offset(page).Limit(limit)\n\n")

						f.WriteString("\tc.JSON(200, " + plural.Plural(modelVar) + ")\n")
						f.WriteString("}\n\n")

						// Get Single Data for Show
						f.WriteString("// Show" + modelName + " to get single data\n")
						f.WriteString("func Show" + modelName + "(c *gin.Context) {\n")
						// Controller functionality here
						f.WriteString("\tid := c.Params.ByName(\"id\")\n")
						f.WriteString("\tvar db = db.DB\n")
						f.WriteString("\tvar " + modelVar + " models." + modelName + "\n")
						f.WriteString("\tdb.Where(\"id=?\",id)" + preloads + ".Find(&" + modelVar + ")\n\n")

						f.WriteString("\tc.JSON(200, " + modelVar + ")\n")
						f.WriteString("}\n\n")
					}
					_, postMethodfound := helper.ArrayFind(methodNames, "post")
					if postMethodfound || allMethodfound {
						// Post Single Data for New
						f.WriteString("// Create" + modelName + " to a new data\n")
						f.WriteString("func Create" + modelName + "(c *gin.Context) {\n")
						// Controller functionality here
						f.WriteString("\tvar db = db.DB\n")
						f.WriteString("\tvar " + modelVar + " models." + modelName + "\n")
						f.WriteString("\tc.BindJSON(&" + modelVar + ")\n")
						f.WriteString("\tdb.Create(&" + modelVar + ")\n\n")
						// if the model is user then create login
						// if args[1] == "User" {

						// 	f.WriteString("\tvar login models.Login\n")
						// 	f.WriteString("\tc.BindJSON(&login)\n")
						// 	f.WriteString("\tif len(login.Username) == 0 {\n")
						// 	f.WriteString("\t\tlogin.Username=" + modelVar + ".UserName\n\t}\n")

						// 	f.WriteString("\tif len(login.Password) == 0 {\n")
						// 	f.WriteString("\t\tlogin.Password=login.Username+\"123\"\n\t}\n")

						// 	f.WriteString("\tdb.Create(&login)\n\n")
						// }
						f.WriteString("\tc.JSON(200, " + modelVar + ")\n")
						f.WriteString("}\n\n")

						// // Post Single Data for Create
						// f.WriteString("func New" + args[1] + "(c *gin.Context) {\n")
						// // Controller functionality here
						// f.WriteString("\tc.JSON(200, \"" + args[1] + " Create page\")\n")
						// f.WriteString("}\n\n")
					}
					_, putMethodfound := helper.ArrayFind(methodNames, "put")
					if putMethodfound || allMethodfound {
						// Update method put
						f.WriteString("// Update" + modelName + " to Update data\n")
						f.WriteString("func Update" + modelName + "(c *gin.Context) {\n")
						// Controller functionality here
						f.WriteString("\tid := c.Params.ByName(\"id\")\n")
						f.WriteString("\tvar db = db.DB\n")
						f.WriteString("\tvar " + modelVar + " models." + modelName + "\n")
						f.WriteString("\tvar " + modelVar2 + " models." + modelName + "\n")
						f.WriteString("\tc.BindJSON(&" + modelVar + ")\n")

						f.WriteString("\tif err := db.Where(\"id=?\",id).Find(&" + modelVar2 + ").Error; err != nil {\n")
						f.WriteString("\t\tc.JSON(404, " + modelVar2 + ")\n")
						f.WriteString("\t\treturn\n\t}\n\n")

						f.WriteString("\tdb.Model(&" + modelVar2 + ").Update(&" + modelVar + ")\n\n")

						f.WriteString("\tc.JSON(200, " + modelVar + ")\n")
						f.WriteString("}\n\n")
					}
					_, deleteMethodfound := helper.ArrayFind(methodNames, "delete")
					if deleteMethodfound || allMethodfound {
						// Get Single Data for Destroy
						f.WriteString("// Destroy" + modelName + " to delete single data\n")
						f.WriteString("func Destroy" + modelName + "(c *gin.Context) {\n")
						// Controller functionality here
						f.WriteString("\tid := c.Params.ByName(\"id\")\n")
						f.WriteString("\tvar db = db.DB\n")
						f.WriteString("\tvar " + modelVar + " models." + modelName + "\n")

						f.WriteString("\tif err := db.Where(\"id=?\",id).Find(&" + modelVar + ").Error; err != nil {\n")
						f.WriteString("\t\tc.JSON(404, " + modelVar + ")\n")
						f.WriteString("\t\treturn\n\t}\n\n")

						f.WriteString("\tdb.Delete(&" + modelVar + ")\n\n")

						f.WriteString("\tc.JSON(200, " + modelVar + ")\n")
						f.WriteString("}\n\n")

					}
					defer f.Close()
					absPath, _ := filepath.Abs(newpath)
					fmt.Println(absPath + "/" + modelName + "Controller.go\n")

					// if code succesfully exicute the return true
					story.UpdateThisStoryStatus("true: Controller Created '" + modelName + "'")
				}
			}
		}
	}
	return true
}

// RoutesGenerator Routes generator
func RoutesGenerator(cmd *cobra.Command, cli helper.CommandChain) bool {

	// routes not working... it should do first, find the fucname and append lines before return
	// return helper.WriteRoutes("routes/API.go", args[1])

	args := cli.GetArgs()
	path := "routes/API.go"
	routeName := args[1]
	var middleware string
	var apiGroup string
	flags := cli.GetFlags()
	for _, flg := range flags {
		if flg.Key == "middleware" {
			middleware = flg.Values[0]
		}
		if flg.Key == "group" {
			apiGroup = flg.Values[0]
		}
	}
	// if api Group flag raised then check or create api group
	if len(apiGroup) > 0 {
		// first create api group
		var newLinesAPIGroup []string
		newLinesAPIGroup = append(newLinesAPIGroup, "\n\t"+apiGroup+" := api.Group(\"/"+apiGroup+"\")\n")
		// append line to main Routes
		lineAfterAPIGroup := []string{
			"r.Group(\"/api\")",
			"Use(middlewares.Cors())",
		}

		// Generate Routes
		helper.AppendLinesInFile(path, lineAfterAPIGroup, newLinesAPIGroup)
	}
	if len(middleware) > 0 {
		rName := helper.IfThenElse(len(apiGroup) > 0, apiGroup, "api")
		var newLinesMiddleware []string
		if middleware == "auth" {
			newLinesMiddleware = append(newLinesMiddleware, "\n\t"+fmt.Sprintf("%v", rName)+".Use(authMiddleware.MiddlewareFunc())")
			newLinesMiddleware = append(newLinesMiddleware, "\t{//"+apiGroup+" Auth route Start \n\n")
			newLinesMiddleware = append(newLinesMiddleware, "\n\t} //"+apiGroup+" Auth Route end\n")
		}

		// append line to main Routes
		lineAfterAPIMiddleWare := []string{
			"api.Group(\"/" + fmt.Sprintf("%v", rName) + "\")",
		}
		// Generate Routes
		helper.AppendLinesInFile(path, lineAfterAPIMiddleWare, newLinesMiddleware)
	}
	lines, err := helper.ScanLines(path)
	helper.ErrorCheck(err)
	var lineNumber int
	var newLines []string
	newLines = append(newLines, "\n\t//"+apiGroup+" Routes generated by bindu for "+routeName+"\n")

	for i, line := range lines {

		if helper.StringsContains(line, "func API") {
			// fmt.Println("Hello")
			lineNumber = i
			newLines = append(newLines, lines[:i+1]...)
			newLines = append(newLines, "\n")
			type route struct {
				key   string
				value string
			}
			routes := []route{
				{key: "GET", value: "Index"},
				{key: "POST", value: "Create"},
				{key: "GET", value: "Show"},
				{key: "PUT", value: "Update"},
				{key: "DELETE", value: "Destroy"},
			}

			for _, r := range routes {
				plural := pluralize.NewClient()
				switch r.value {
				case "Index":
					newLines = append(newLines, "\t"+fmt.Sprintf("%v", helper.IfThenElse(len(apiGroup) > 0, apiGroup, "api"))+"."+r.key+"(\"/"+strings.ToLower(plural.Plural(routeName))+"/:page\", controllers."+r.value+routeName+")")
				case "Create":
					newLines = append(newLines, "\t"+fmt.Sprintf("%v", helper.IfThenElse(len(apiGroup) > 0, apiGroup, "api"))+"."+r.key+"(\"/"+strings.ToLower(routeName)+"\", controllers."+r.value+routeName+")")

				case "Show":
					newLines = append(newLines, "\t"+fmt.Sprintf("%v", helper.IfThenElse(len(apiGroup) > 0, apiGroup, "api"))+"."+r.key+"(\"/"+strings.ToLower(routeName)+"/:id\", controllers."+r.value+routeName+")")

				case "Update":
					newLines = append(newLines, "\t"+fmt.Sprintf("%v", helper.IfThenElse(len(apiGroup) > 0, apiGroup, "api"))+"."+r.key+"(\"/"+strings.ToLower(routeName)+"/:id\", controllers."+r.value+routeName+")")
				case "Destroy":
					newLines = append(newLines, "\t"+fmt.Sprintf("%v", helper.IfThenElse(len(apiGroup) > 0, apiGroup, "api"))+"."+r.key+"(\"/"+strings.ToLower(routeName)+"/:id\", controllers."+r.value+routeName+")")

				}
			}

		}

	}

	if lineNumber > 0 {
		newLines = append(newLines, lines[lineNumber+1:]...)
		// ioutil.WriteFile(path, []byte(strings.Join(newLines, "\n")), 0644)
		// append line to main Routes
		// first check if the flag raised the group or middleware
		// if flag exist apiGroup
		newLineAfter := helper.IfThenElse(len(apiGroup) > 0, "api.Group(\"/"+apiGroup+"\")", "r.Group(\"/api\")")
		// if flag exist middleware
		newLineAfter = helper.IfThenElse(len(middleware) > 0, "api.Use(authMiddleware.MiddlewareFunc())", newLineAfter)
		// if flag exist apigrou and middleware both
		newLineAfter = helper.IfThenElse(len(middleware) > 0 && len(apiGroup) > 0, apiGroup+".Use(authMiddleware.MiddlewareFunc())", newLineAfter)
		lineAfter := []string{
			fmt.Sprintf("%v", newLineAfter),
		}

		fmt.Println("Generating Routes....")
		// Generate Routes
		// inpur path, lineAfter, offset, newlines
		if len(middleware) > 0 {
			// because of middleware { } bracket need to offset 1
			helper.AppendLinesInFileNext(path, lineAfter, 1, newLines)
		} else {
			helper.AppendLinesInFileNext(path, lineAfter, 0, newLines)
		}

		fmt.Println("Done!")
	}
	return true

}
